/*************************************************************************
	> File Name: n个骰子的点数.cpp
	> Author: 
	> Mail: 
	> Created Time: 四  2/20 22:52:43 2020
 ************************************************************************/
/***
 面试题60. n个骰子的点数把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

 示例 1:
 
 输入: 1
 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
 示例 2:
 
 输入: 2
 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]

 **/
class Solution {
public:
    vector<double> twoSum(int n) {
        vector<vector<int>> dp(n+1, vector<int>(6*n+1));
        /*一个骰子的时候，分数只能从1-6，并且出现的情况只有1种*/
        for(int i=1; i<=6; i++){
            dp[1][i] = 1;
        }
        /*从两个骰子开始算*/
        for(int k=2; k<=n; k++){
            /*此时k个骰子最低点数总和为k,最高点数总和为6*k,计算F(k,i)的情况总数 */
            for(int i=k; i<=6*k; i++){
                for(int d=1; d<=6; d++){
                    /*若所求分数减去点数小于0，那之后的点数可以忽略*/
                    if(i-d<=0){
                        break;
                    }else{
                        /*否则将计算这次的总数等于上次分数的情况之和,即F(k,i)=F(k-1,i-1)+F(K-1,i-2)+F(k-1,i-3)+....+F(k-1,i-6)，因为这次点数可能为1-6与其中一种情况匹配*/
                        dp[k][i] += dp[k-1][i-d];
                    }
                    
                }
            }
        }
        double total = pow(6.0, (double)n);
        vector<double> res;
        /*因为n个骰子点数之和最小为n,最大为6*n */
        for(int i=n; i<=6*n; i++){
            /*用每一个点数之和的情况除以总情况就是概率*/
            res.push_back((double)dp[n][i]/total);
        }
        return res;
    }
};

